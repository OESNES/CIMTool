<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:a="http://langdale.com.au/2005/Message#">

	<xsl:output indent="yes" />
	<xsl:param name="version"></xsl:param>
	<xsl:param name="baseURI"></xsl:param>
	<xsl:param name="envelope">Profile</xsl:param>

	<xsl:template match="a:Catalog">
		<!--  the top level template generates the xml schema element -->
		<xs:schema targetNamespace="{$baseURI}"
			elementFormDefault="qualified" attributeFormDefault="unqualified">

			<!-- copy through namespace declaration needed to reference local types -->
			<xsl:for-each select="namespace::*">
				<xsl:copy />
			</xsl:for-each>

			<xs:annotation>
				<xs:documentation>
					Generated by CIMTool
					<xsl:value-of select="$version" />
					, see https://cimtool.ucaiug.io
				</xs:documentation>
			</xs:annotation>

			<!-- if the message declares root elements put them in an envelope -->
			<xsl:if test="a:Root">
				<xs:element name="{$envelope}">
					<xs:complexType>
						<xs:sequence>
							<xsl:apply-templates select="a:Root"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				
			</xsl:if>
			<xsl:apply-templates select="a:Message" />
			<xsl:apply-templates mode="declare" />

		</xs:schema>
	</xsl:template>

	<xsl:template match="a:Message">
		<!--  generates an envelope element -->
		<xs:element name="{@name}">
			<xsl:apply-templates mode="annotate" />
			<xs:complexType>
				<xs:sequence>
					<xsl:apply-templates />
				</xs:sequence>
			</xs:complexType>
		</xs:element>
	</xsl:template>

	<xsl:template match="a:Root">
		<!--  generates the payload element definitions -->
		<xs:element name="{@name}" type="m:{@name}" minOccurs="0"
			maxOccurs="unbounded" />
	</xsl:template>

	<xsl:template match="a:Complex">
		<!--  generates an element with complex type declared inline -->
		<xs:element name="{@name}" minOccurs="{@minOccurs}"
			maxOccurs="{@maxOccurs}">
			<xsl:apply-templates mode="annotate" />
			<xs:complexType>
				<xsl:call-template  name="type_body" />
			</xs:complexType>
		</xs:element>
	</xsl:template>

	<xsl:template match="a:Instance|a:Domain|a:Enumerated">
		<!--  generates an instance of a complex type or simple type declared elsewhere -->
		<xs:element name="{@name}" minOccurs="{@minOccurs}"
			maxOccurs="{@maxOccurs}" type="m:{@type}">
			<xsl:apply-templates mode="annotate" />
		</xs:element>
	</xsl:template>

	<xsl:template match="a:Simple">
		<!--  generates an element for an xsd part 2 simple type -->
		<xs:element name="{@name}" minOccurs="{@minOccurs}"
			maxOccurs="{@maxOccurs}" type="xs:{@xstype}">
			<xsl:apply-templates mode="annotate" />
		</xs:element>
	</xsl:template>

	<xsl:template match="a:Reference">
		<!-- generates a reference to an object in the model -->
		<xs:element name="{@name}" minOccurs="{@minOccurs}"
			maxOccurs="{@maxOccurs}">
			<xsl:apply-templates mode="annotate" />
			<xs:complexType>
				<xs:attribute name="ref" type="xs:string" />
			</xs:complexType>
		</xs:element>
	</xsl:template>

	<xsl:template name="type_body">
		<!-- generates the meat of a complex type, including an extension if necessary -->
		<xsl:choose>
			<xsl:when test="a:SuperType">
				<xs:complexContent>
					<xs:extension base="m:{a:SuperType/@name}">
						<xs:sequence>
							<xsl:apply-templates />
						</xs:sequence>
					</xs:extension>
				</xs:complexContent>
			</xsl:when>
			<xsl:otherwise>
				<xs:sequence>
					<xsl:apply-templates />
				</xs:sequence>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template match="a:ComplexType|a:Root" mode="declare">
		<xs:complexType name="{@name}">
			<xsl:apply-templates mode="annotate" />
			<xsl:call-template  name="type_body" />
		</xs:complexType>
	</xsl:template>

	<xsl:template match="a:SimpleType" mode="declare">
		<!--  declares a a CIM domain type in terms of an xsd part 2 simple type -->
		<xs:simpleType name="{@name}">
			<xsl:apply-templates mode="annotate" />
			<xs:restriction base="xs:{@xstype}" />
		</xs:simpleType>
	</xsl:template>

	<xsl:template match="a:EnumeratedType" mode="declare">
		<!-- declares an enumerated type -->
		<xs:simpleType name="{@name}">
			<xsl:apply-templates mode="annotate" />
			<xs:restriction base="xs:string">
				<xsl:apply-templates mode="declare" />
			</xs:restriction>
		</xs:simpleType>
	</xsl:template>

	<xsl:template match="a:EnumeratedValue" mode="declare">
		<!-- declares one value within an enumerated type -->
		<xs:enumeration value="{@name}">
			<xsl:apply-templates mode="annotate" />
		</xs:enumeration>
	</xsl:template>


	<xsl:template match="a:Comment" mode="annotate">
		<!--  generate and annotation -->
		<xs:annotation>
			<xs:documentation>
				<xsl:value-of select="." />
			</xs:documentation>
		</xs:annotation>
	</xsl:template>

	<xsl:template match="text()">
		<!--  dont pass text through  -->
	</xsl:template>

	<xsl:template match="node()" mode="annotate">
		<!-- dont pass any defaults in annotate mode -->
	</xsl:template>

	<xsl:template match="node()" mode="declare">
		<!-- dont pass any defaults in declare mode -->
	</xsl:template>

</xsl:stylesheet>